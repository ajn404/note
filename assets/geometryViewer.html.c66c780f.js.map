{"version":3,"mappings":"gXAsBA,YACAA,mBACAC,IACA,iEAEA,EAEAC,UACAC,UACAC,QACAC,OACAC,YACA,QACA,0BACA,cACA,+BACA,GAEA,MACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAEA,cACAC,aACAhB,8BACAC,+BACAC,uCACAC,2DACAC,8CACAC,+CACAC,+BACAC,gCACAC,kCACAC,mCACAC,yCACAC,0CACAM,QAEA,aAyXA,mBACA,uBACAC,qBACAC,mBACA,EACAD,sBACA,EAEAE,iBAIA,GAHAC,KACAC,MAEAC,SACAC,MACA,qBACA,UACAC,eAEAC,uBACA,oBACA,6BACAC,gCACAA,mCACAC,iBAEA,YACA,uBACA,mBACA,oBACA,EACAD,2BACA,MACAA,eACAE,QACA,CAEA,EAEAL,MACA,iBACA,QAGA,gBACA,gBACAM,wBACAC,iBACA,qBAEAC,kBACA,kBACA,YACAC,IACAA,OACAL,iBAEAT,QACAO,uBACA,EACA,CACA,CACA,EArbAL,KACAa,UAEA,iCAGAH,eACAG,6CAEA,QACAA,yCACAC,OACAA,QAGAC,gCAGAC,eAGAX,OACA,oEACAY,IACAP,MACAQ,WAEA1B,UACA,CACA,CACA,EAEA2B,OACA,mBACA,mBACA,EAIAC,gCACAA,yCAEA,sCACAC,iCAEAA,gCACA,iCACAD,+BACA,GAEA,wBACAE,2BACA,4BAEA,oDAGA,8DAGA,aAEA,IADAA,qBACAf,cACAA,2BAEA,EAEAJ,OACAZ,iBACA,aACA,qBACA,GACAE,kBACAD,sBACAA,2CAEAe,iBACAA,iBAEAb,kBACAD,cAEAiB,QACA,uBACAY,iCACAZ,kBACAY,4BAGAA,qBACAA,kBACA/B,8BAEA,EAEAO,WAEA,yCACAyB,0BACAA,6BACA,IACAd,GACA,2DACAA,YACA,EACA,SAEA,yCACAe,0BACAA,aACA,eACA,SACA,YACA,UACA,mBACA,EACA,IACA,OACA,0DACAf,YACA,EACA,SACAe,gBAEA,yCACAC,0BAEA,yCACAC,0BACAA,uBAEA,wCACAC,0BACAA,+BACAA,8BACAA,4BACAA,0BAEA,wCACAC,0BACAA,cAEA,yCACAC,0BACAA,uBAEA,sCACAC,kCACAA,iBACAA,iBACAA,iBACAA,iBACAA,iBACAA,iBAGA,uBACA,iDACAvC,iDAEAuC,iBAEAV,iBAGA,yBACAW,yBAEA,wBACAC,sBACAC,iBACA,mCACA,6BACA,cACA,mBACA,GACAC,kBACAC,iCACAC,oCACA,QAMA,aACA,mCACAC,mBACAA,6BACAA,gBACA7C,UACA,CACA8C,IACAf,+BAMA,eACA,4BACA,WACA,YACAW,yDACAA,qBACA1C,UACA,CACAgC,gCAMA,eACA,mCACAU,8BACA1C,UACA,CAEAmC,+BAMA,kDACAK,EACA,eACA,YACA,SACA,2BACA,gCACA,IACAA,EACA,cACA,YACA,SACA,2BACA,+BACA,GACA,EACAP,eACA,IACA,qBACA,2DACAc,YACA,EACA,SAEA,eACA,qCACAC,kBACA,iBACAC,aACA,oBACA,OAGAC,EADAV,iCAEA,sBACAI,WACAA,WACAO,iBACAF,GACAG,gBACAtD,uBACAA,sBAEA,mCACA,SAEA2C,oBACAA,mBACA,2BAEAP,wBACA,sBACA,mBACAmB,gCAEAnB,cACA,uDACA,QACA,MACAA,uBAEAhC,kBACAA,mBACA,MACAgC,uBACAhC,oBAEAuC,OACA,mBACA,aACA,kCACA,cACA,mBACA,GACAK,GACA,CACAb,gCACAqB,eAEA,eACA,uBACA,2BACA,uBACAC,iCACA,CACAA,6BACAA,6CACA,2CACAX,UACAA,UACAC,6BACAU,eACA,CACAvD,UACA,CACA,CACAkC,gCAMA,cAEAG,4BACAtC,0BACAA,EACA,6BACA,YACAsC,0BAEAtC,4BACAA,0CACAsC,yBAEA,CACAA,+BAMAK,eACAD,kBACAxC,cAEAC,yCAGA,yBACA2C,oBAGA5C,gBACAD,WAEAjB,SACA,QACA,SACA,SACA,cACA,WACA,eACA,yBACA,gBACA,EAGA+C,UACA,EAiEA0B,OACA,gBACAC,iCACAC,mBAEAA,OACAA,8BAEA,sCACAC,gHACAD,iBAEA,iCAEA,cACA/B,MACA,uBACAiC,0BACAA,aACAF,iBACAnD,gBACAvB,WAEA,CAEA6E,+BACAF,6BACAA,yCACAA,iCACA,EAEA,qBAEA,QADA7E,QAGA4E,GACAA,8BAGAnD,OACA,CAEA,gBACAC,GACAgD,WAEA,MAEA,CAEA,EACA,EAEA,eACA3E,IACA,WAQAiF,MANA3D,OACA4D,wFACAD,IACA,IAMA,GAEAE,QACA,eACA,MACA,yBACA,eACA,WACA,gBACA,UACA/D,WACAD,WACAE,WACA,8CACAH,WACAhB,YACA,CACA","names":["e","isClient","vtkContainer","context","txt","loading","ElLoading","vtkActor","vtkDataArray","vtkScalarBarActor","vtkColorMaps","vtkColorTransferFunction","vtkFullScreenRenderWindow","vtkMapper","vtkURLExtract","vtkXMLPolyDataReader","vtkFPSMonitor","ColorMode","ScalarMode","fullScreenRenderWindow","renderWindow","renderer","scalarBarActor","loadInstance","nextTick","reader","createPipeline","load","autoInit","emptyContainer","options","createViewer","loadFile","updateCamera","progressContainer","container","progressEvent","name","userParams","HttpDataAccessHelper","nbLoadedData","background","style","lutName","field","key","camera","preventDefaults","rootControllerContainer","addDataSetButton","fpsMonitor","presetSelector","representationSelector","colorBySelector","componentSelector","opacitySelector","labelSelector","immersionSelector","controlContainer","vtpReader","source","mapper","actor","scalars","dataRange","lookupTable","applyPreset","label","interpolateScalarsBeforeMapping","scalarMode","activeArray","colorMode","location","compOpts","updateColorBy","lut","initLocalFileLoader","rootBody","myContainer","fileContainer","files","fileInput","loadViewer","__vitePreload","onBeforeUnmount"],"sources":["../../../components/vtk/geometryViewer.vue"],"sourcesContent":["<template>\n    <div class=\"geometry-viewer\">\n        <div class=\"vtk-container\" ref=\"vtkContainer\" />\n        <objectification class=\"fixed\" ref=\"txtRef\" v-show=\"txt\" text=\"点击图片上传vtp文件,点击本文字下载示例文件\" @click.prevent=\"downloadVtp\"></objectification>\n    </div>\n</template>\n\n<script setup>\n\n\nimport { ref, onMounted, onBeforeUnmount, nextTick } from \"vue\";\nimport { isClient } from \"@vueuse/core\";\nimport { ElLoading } from \"element-plus\";\n\nimport { formatBytesToProperUnit, debounce } from '@kitware/vtk.js/macros';\nimport '@kitware/vtk.js/Rendering/Profiles/Geometry';\nimport HttpDataAccessHelper from '@kitware/vtk.js/IO/Core/DataAccessHelper/HttpDataAccessHelper';\nimport '@kitware/vtk.js/IO/Core/DataAccessHelper/HtmlDataAccessHelper';\nimport '@kitware/vtk.js/IO/Core/DataAccessHelper/JSZipDataAccessHelper';\n\nimport style from './geometryViewer.module.css'\n\nconst downloadVtp = e=>{\n    e.preventDefault()\n    if(isClient){\n        window.location.href='/note/data/diskout-stream-binary-zlib.vtp'\n    }\n}\n\nconst vtkContainer = ref(null);\nconst context = ref(null);\nconst txt = ref(true)\nconst loading = () => {\n    return ElLoading.service({\n        lock: true,\n        text: \"加载中\",\n        fullscreen: true,\n        background: \"rgba(0, 0, 0, 0.7)\",\n    });\n};\nlet loadInstance;\nlet vtkActor,\n    vtkDataArray,\n    vtkScalarBarActor,\n    vtkColorMaps,\n    vtkColorTransferFunction,\n    vtkFullScreenRenderWindow,\n    vtkMapper,\n    vtkURLExtract,\n    vtkXMLPolyDataReader,\n    vtkFPSMonitor;\nlet ColorMode,\n    ScalarMode;\nlet fullScreenRenderWindow;\nlet renderWindow;\nlet renderer;\nlet scalarBarActor;\n\nconst loadViewer = () => {\n    if (loadInstance) loadInstance.close()\n    vtkActor = vtk.Rendering.Core.vtkActor;\n    vtkDataArray = vtk.Common.Core.vtkDataArray;\n    vtkScalarBarActor = vtk.Rendering.Core.vtkScalarBarActor;\n    vtkColorMaps = vtk.Rendering.Core.vtkColorTransferFunction.vtkColorMaps;\n    vtkColorTransferFunction = vtk.Rendering.Core.vtkColorTransferFunction;\n    vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;\n    vtkMapper = vtk.Rendering.Core.vtkMapper\n    vtkURLExtract = vtk.Common.Core.vtkURLExtract;\n    vtkXMLPolyDataReader = vtk.IO.XML.vtkXMLPolyDataReader\n    vtkFPSMonitor = vtk.Interaction.UI.vtkFPSMonitor\n    ColorMode = vtk.Rendering.Core.vtkMapper.ColorMode\n    ScalarMode = vtk.Rendering.Core.vtkMapper.ScalarMode\n    nextTick(() => {\n\n        if (!context.value) {\n            let autoInit = true;\n            let background = [0, 0, 0];\n            // Process arguments from URL\n            const userParams = vtkURLExtract.extractURLParameters();\n\n            // Background handling\n            if (userParams.background) {\n                background = userParams.background.split(',').map((s) => Number(s));\n            }\n            const selectorClass =\n                background.length === 3 && background.reduce((a, b) => a + b, 0) < 1.5\n                    ? style.dark\n                    : style.light;\n\n            // lut\n            const lutName = userParams.lut || 'erdc_rainbow_bright';\n\n            // field\n            const field = userParams.field || '';\n\n\n            const updateCamera = camera => {\n                ['zoom', 'pitch', 'elevation', 'yaw', 'azimuth', 'roll', 'dolly'].forEach(\n                    (key) => {\n                        if (userParams[key]) {\n                            camera[key](userParams[key]);\n                        }\n                        renderWindow.render();\n                    }\n                );\n            }\n\n            const preventDefaults = e => {\n                e.preventDefault();\n                e.stopPropagation();\n            }\n\n\n\n            const rootControllerContainer = document.createElement('div');\n            rootControllerContainer.setAttribute('class', style.rootController);\n\n            const addDataSetButton = document.createElement('img');\n            addDataSetButton.setAttribute('class', style.button);\n            // addDataSetButton.setAttribute('src', icon);\n            addDataSetButton.addEventListener('click', () => {\n                const isVisible = rootControllerContainer.style.display !== 'none';\n                rootControllerContainer.style.display = isVisible ? 'none' : 'flex';\n            });\n\n            const fpsMonitor = vtkFPSMonitor.newInstance();\n            const fpsElm = fpsMonitor.getFpsMonitorContainer();\n            fpsElm.classList.add(style.fpsMonitor);\n\n            const iOS = /iPad|iPhone|iPod/.test(window.navigator.platform);\n\n            if (iOS) {\n                document.querySelector('body').classList.add('is-ios-device');\n            }\n\n            const emptyContainer = container => {\n                fpsMonitor.setContainer(null);\n                while (container.firstChild) {\n                    container.removeChild(container.firstChild);\n                }\n            }\n\n            const createViewer = container => {\n                fullScreenRenderWindow = vtkFullScreenRenderWindow.newInstance({\n                    background,\n                    rootContainer: vtkContainer.value,\n                });\n                renderer = fullScreenRenderWindow.getRenderer();\n                renderWindow = fullScreenRenderWindow.getRenderWindow();\n                renderWindow.getInteractor().setDesiredUpdateRate(15);\n\n                container.appendChild(rootControllerContainer);\n                container.appendChild(addDataSetButton);\n\n                scalarBarActor = vtkScalarBarActor.newInstance();\n                renderer.addActor(scalarBarActor);\n\n                if (userParams.fps) {\n                    if (Array.isArray(userParams.fps)) {\n                        fpsMonitor.setMonitorVisibility(...userParams.fps);\n                        if (userParams.fps.length === 4) {\n                            fpsMonitor.setOrientation(userParams.fps[3]);\n                        }\n                    }\n                    fpsMonitor.setRenderWindow(renderWindow);\n                    fpsMonitor.setContainer(container);\n                    fullScreenRenderWindow.setResizeCallback(fpsMonitor.update);\n                }\n            }\n\n            const createPipeline = (fileName, fileContents) => {\n                // Create UI\n                const presetSelector = document.createElement('select');\n                presetSelector.setAttribute('class', selectorClass);\n                presetSelector.innerHTML = vtkColorMaps.rgbPresetNames\n                    .map(\n                        (name) =>\n                            `<option value=\"${name}\" ${lutName === name ? 'selected=\"selected\"' : ''\n                            }>${name}</option>`\n                    )\n                    .join('');\n\n                const representationSelector = document.createElement('select');\n                representationSelector.setAttribute('class', selectorClass);\n                representationSelector.innerHTML = [\n                    '隐藏',\n                    'Points',\n                    'Wireframe',\n                    'Surface',\n                    'Surface with Edge',\n                ]\n                    .map(\n                        (name, idx) =>\n                            `<option value=\"${idx === 0 ? 0 : 1}:${idx < 4 ? idx - 1 : 2}:${idx === 4 ? 1 : 0\n                            }\">${name}</option>`\n                    )\n                    .join('');\n                representationSelector.value = '1:2:0';\n\n                const colorBySelector = document.createElement('select');\n                colorBySelector.setAttribute('class', selectorClass);\n\n                const componentSelector = document.createElement('select');\n                componentSelector.setAttribute('class', selectorClass);\n                componentSelector.style.display = 'none';\n\n                const opacitySelector = document.createElement('input');\n                opacitySelector.setAttribute('class', selectorClass);\n                opacitySelector.setAttribute('type', 'range');\n                opacitySelector.setAttribute('value', '100');\n                opacitySelector.setAttribute('max', '100');\n                opacitySelector.setAttribute('min', '1');\n\n                const labelSelector = document.createElement('label');\n                labelSelector.setAttribute('class', selectorClass);\n                labelSelector.innerHTML = fileName;\n\n                const immersionSelector = document.createElement('button');\n                immersionSelector.setAttribute('class', selectorClass);\n                immersionSelector.innerHTML = 'Start AR';\n\n                const controlContainer = document.createElement('div');\n                controlContainer.setAttribute('class', style.control);\n                controlContainer.appendChild(labelSelector);\n                controlContainer.appendChild(representationSelector);\n                controlContainer.appendChild(presetSelector);\n                controlContainer.appendChild(colorBySelector);\n                controlContainer.appendChild(componentSelector);\n                controlContainer.appendChild(opacitySelector);\n\n                if (\n                    navigator.xr !== undefined &&\n                    navigator.xr.isSessionSupported('immersive-ar') &&\n                    fullScreenRenderWindow.getApiSpecificRenderWindow().getXrSupported()\n                ) {\n                    controlContainer.appendChild(immersionSelector);\n                }\n                rootControllerContainer.appendChild(controlContainer);\n\n                // VTK pipeline\n                const vtpReader = vtkXMLPolyDataReader.newInstance();\n                vtpReader.parseAsArrayBuffer(fileContents);\n\n                const lookupTable = vtkColorTransferFunction.newInstance();\n                const source = vtpReader.getOutputData(0);\n                const mapper = vtkMapper.newInstance({\n                    interpolateScalarsBeforeMapping: false,\n                    useLookupTableScalarRange: true,\n                    lookupTable,\n                    scalarVisibility: false,\n                });\n                const actor = vtkActor.newInstance();\n                const scalars = source.getPointData().getScalars();\n                const dataRange = [].concat(scalars ? scalars.getRange() : [0, 1]);\n                let activeArray = vtkDataArray;\n\n                // --------------------------------------------------------------------\n                // Color handling\n                // --------------------------------------------------------------------\n\n                function applyPreset() {\n                    const preset = vtkColorMaps.getPresetByName(presetSelector.value);\n                    lookupTable.applyColorMap(preset);\n                    lookupTable.setMappingRange(dataRange[0], dataRange[1]);\n                    lookupTable.updateRange();\n                    renderWindow.render();\n                }\n                applyPreset();\n                presetSelector.addEventListener('change', applyPreset);\n\n                // --------------------------------------------------------------------\n                // Representation handling\n                // --------------------------------------------------------------------\n\n                function updateRepresentation(event) {\n                    const [visibility, representation, edgeVisibility] = event.target.value\n                        .split(':')\n                        .map(Number);\n                    actor.getProperty().set({ representation, edgeVisibility });\n                    actor.setVisibility(!!visibility);\n                    renderWindow.render();\n                }\n                representationSelector.addEventListener('change', updateRepresentation);\n\n                // --------------------------------------------------------------------\n                // Opacity handling\n                // --------------------------------------------------------------------\n\n                function updateOpacity(event) {\n                    const opacity = Number(event.target.value) / 100;\n                    actor.getProperty().setOpacity(opacity);\n                    renderWindow.render();\n                }\n\n                opacitySelector.addEventListener('input', updateOpacity);\n\n                // --------------------------------------------------------------------\n                // ColorBy handling\n                // --------------------------------------------------------------------\n\n                const colorByOptions = [{ value: ':', label: 'Solid color' }].concat(\n                    source\n                        .getPointData()\n                        .getArrays()\n                        .map((a) => ({\n                            label: `(p) ${a.getName()}`,\n                            value: `PointData:${a.getName()}`,\n                        })),\n                    source\n                        .getCellData()\n                        .getArrays()\n                        .map((a) => ({\n                            label: `(c) ${a.getName()}`,\n                            value: `CellData:${a.getName()}`,\n                        }))\n                );\n                colorBySelector.innerHTML = colorByOptions\n                    .map(\n                        ({ label, value }) =>\n                            `<option value=\"${value}\" ${field === value ? 'selected=\"selected\"' : ''\n                            }>${label}</option>`\n                    )\n                    .join('');\n\n                function updateColorBy(event) {\n                    const [location, colorByArrayName] = event.target.value.split(':');\n                    const interpolateScalarsBeforeMapping = location === 'PointData';\n                    let colorMode = ColorMode.DEFAULT;\n                    let scalarMode = ScalarMode.DEFAULT;\n                    const scalarVisibility = location.length > 0;\n                    if (scalarVisibility) {\n                        const newArray =\n                            source[`get${location}`]().getArrayByName(colorByArrayName);\n                        activeArray = newArray;\n                        const newDataRange = activeArray.getRange();\n                        dataRange[0] = newDataRange[0];\n                        dataRange[1] = newDataRange[1];\n                        colorMode = ColorMode.MAP_SCALARS;\n                        scalarMode =\n                            location === 'PointData'\n                                ? ScalarMode.USE_POINT_FIELD_DATA\n                                : ScalarMode.USE_CELL_FIELD_DATA;\n\n                        const numberOfComponents = activeArray.getNumberOfComponents();\n                        if (numberOfComponents > 1) {\n                            // always start on magnitude setting\n                            if (mapper.getLookupTable()) {\n                                const lut = mapper.getLookupTable();\n                                lut.setVectorModeToMagnitude();\n                            }\n                            componentSelector.style.display = 'block';\n                            const compOpts = ['Magnitude'];\n                            while (compOpts.length <= numberOfComponents) {\n                                compOpts.push(`Component ${compOpts.length}`);\n                            }\n                            componentSelector.innerHTML = compOpts\n                                .map((t, index) => `<option value=\"${index - 1}\">${t}</option>`)\n                                .join('');\n                        } else {\n                            componentSelector.style.display = 'none';\n                        }\n                        scalarBarActor.setAxisLabel(colorByArrayName);\n                        scalarBarActor.setVisibility(true);\n                    } else {\n                        componentSelector.style.display = 'none';\n                        scalarBarActor.setVisibility(false);\n                    }\n                    mapper.set({\n                        colorByArrayName,\n                        colorMode,\n                        interpolateScalarsBeforeMapping,\n                        scalarMode,\n                        scalarVisibility,\n                    });\n                    applyPreset();\n                }\n                colorBySelector.addEventListener('change', updateColorBy);\n                updateColorBy({ target: colorBySelector });\n\n                function updateColorByComponent(event) {\n                    if (mapper.getLookupTable()) {\n                        const lut = mapper.getLookupTable();\n                        if (event.target.value === -1) {\n                            lut.setVectorModeToMagnitude();\n                        } else {\n                            lut.setVectorModeToComponent();\n                            lut.setVectorComponent(Number(event.target.value));\n                            const newDataRange = activeArray.getRange(Number(event.target.value));\n                            dataRange[0] = newDataRange[0];\n                            dataRange[1] = newDataRange[1];\n                            lookupTable.setMappingRange(dataRange[0], dataRange[1]);\n                            lut.updateRange();\n                        }\n                        renderWindow.render();\n                    }\n                }\n                componentSelector.addEventListener('change', updateColorByComponent);\n\n                // --------------------------------------------------------------------\n                // Immersion handling\n                // --------------------------------------------------------------------\n\n                function toggleAR() {\n                    const SESSION_IS_AR = true;\n                    if (immersionSelector.textContent === 'Start AR') {\n                        fullScreenRenderWindow.setBackground([...background, 0]);\n                        fullScreenRenderWindow\n                            .getApiSpecificRenderWindow()\n                            .startXR(SESSION_IS_AR);\n                        immersionSelector.textContent = 'Exit AR';\n                    } else {\n                        fullScreenRenderWindow.setBackground([...background, 255]);\n                        fullScreenRenderWindow.getApiSpecificRenderWindow().stopXR(SESSION_IS_AR);\n                        immersionSelector.textContent = 'Start AR';\n                    }\n                }\n                immersionSelector.addEventListener('click', toggleAR);\n\n                // --------------------------------------------------------------------\n                // Pipeline handling\n                // --------------------------------------------------------------------\n\n                actor.setMapper(mapper);\n                mapper.setInputData(source);\n                renderer.addActor(actor);\n\n                scalarBarActor.setScalarsToColors(mapper.getLookupTable());\n\n                // Manage update when lookupTable change\n                const debouncedRender = debounce(renderWindow.render, 10);\n                lookupTable.onModified(debouncedRender, -1);\n\n                // First render\n                renderer.resetCamera();\n                renderWindow.render();\n\n                context.value = {\n                    actor,\n                    mapper,\n                    source,\n                    lookupTable,\n                    renderer,\n                    renderWindow,\n                    fullScreenRenderWindow,\n                    scalarBarActor\n                };\n\n                // Update stats\n                fpsMonitor.update();\n            }\n\n            function loadFile(file) {\n                const reader = new FileReader();\n                reader.onload = function onLoad(e) {\n                    createPipeline(file.name, reader.result);\n                };\n                reader.readAsArrayBuffer(file);\n            }\n\n            function load(container, options) {\n                autoInit = false;\n                emptyContainer(container);\n\n                if (options.files) {\n                    createViewer(container);\n                    let count = options.files.length;\n                    while (count--) {\n                        loadFile(options.files[count]);\n                    }\n                    updateCamera(renderer.getActiveCamera());\n                } else if (options.fileURL) {\n                    const urls = [].concat(options.fileURL);\n                    const progressContainer = document.createElement('div');\n                    progressContainer.setAttribute('class', style.progress);\n                    container.appendChild(progressContainer);\n\n                    const progressCallback = (progressEvent) => {\n                        if (progressEvent.lengthComputable) {\n                            const percent = Math.floor(\n                                (100 * progressEvent.loaded) / progressEvent.total\n                            );\n                            progressContainer.innerHTML = `Loading ${percent}%`;\n                        } else {\n                            progressContainer.innerHTML = formatBytesToProperUnit(\n                                progressEvent.loaded\n                            );\n                        }\n                    };\n\n                    createViewer(container);\n                    const nbURLs = urls.length;\n                    let nbLoadedData = 0;\n\n                    /* eslint-disable no-loop-func */\n                    while (urls.length) {\n                        const url = urls.pop();\n                        const name = Array.isArray(userParams.name)\n                            ? userParams.name[urls.length]\n                            : `Data ${urls.length + 1}`;\n\n                        HttpDataAccessHelper.fetchBinary(url, {\n                            progressCallback,\n                        }).then((binary) => {\n                            nbLoadedData++;\n                            if (nbLoadedData === nbURLs) {\n                                container.removeChild(progressContainer);\n                            }\n                            createPipeline(name, binary);\n                            updateCamera(renderer.getActiveCamera());\n                        });\n                    }\n                }\n            }\n\n            const initLocalFileLoader = container => {\n                const exampleContainer = vtkContainer.value;\n                const rootBody = document.querySelector('body');\n                const myContainer = vtkContainer.value || container || exampleContainer || rootBody;\n\n                if (myContainer !== container) {\n                    myContainer.classList.add(style.fullScreen);\n                }\n                const fileContainer = document.createElement('div');\n                fileContainer.innerHTML = `<div class=\"${style.bigFileDrop}\"/><input type=\"file\" multiple accept=\".vtp\" style=\"display: none;\"/>`;\n                myContainer.appendChild(fileContainer);\n\n                const fileInput = fileContainer.querySelector('input');\n\n                function handleFile(e) {\n                    preventDefaults(e);\n                    const dataTransfer = e.dataTransfer;\n                    const files = e.target.files || dataTransfer.files;\n                    if (files.length > 0) {\n                        myContainer.removeChild(fileContainer);\n                        load(myContainer, { files });\n                        txt.value = false\n                    }\n                }\n\n                fileInput.addEventListener('change', handleFile);\n                fileContainer.addEventListener('drop', handleFile);\n                fileContainer.addEventListener('click', (e) => fileInput.click());\n                fileContainer.addEventListener('dragover', preventDefaults);\n            }\n\n            if (userParams.url || userParams.fileURL) {\n                const exampleContainer = vtkContainer.value;\n                const myContainer = exampleContainer;\n\n                if (myContainer) {\n                    myContainer.classList.add(style.fullScreen);\n                }\n\n                load(myContainer, userParams);\n            }\n\n            setTimeout(() => {\n                if (autoInit) {\n                    initLocalFileLoader(vtkContainer.value);\n                }\n            }, 100);\n\n        }\n\n    })\n}\n\nonMounted(() => {\n    if (isClient) {\n        let vtk = window[\"vtk\"]\n        if (!vtk) {\n            loadInstance = loading();\n            import(\"https://unpkg.com/vtk.js/Sources/@25.1.0/vtk.js/Sources/\").then(() => {\n                loadViewer()\n            });\n        }\n        else {\n            loadViewer()\n        }\n    }\n});\n\nonBeforeUnmount(() => {\n    if (context.value && isClient) {\n        const {\n            fullScreenRenderWindow,\n            renderWindow,\n            renderer,\n            scalarBarActor\n        } = context.value;\n        renderer.delete();\n        renderWindow.delete();\n        scalarBarActor.delete();\n        window.removeEventListener(\"resize\", fullScreenRenderWindow.resize);\n        fullScreenRenderWindow.delete();\n        context.value = null;\n    }\n});\n\n</script>\n\n<style lang=\"scss\" scoped>\n.geometry-viewer {\n    min-width: 100%;\n}\n\n.fixed{\n    position: absolute;\n    bottom: 0;\n    z-index: 9999;\n    cursor: pointer;\n}\n</style>\n  \n    "],"file":"assets/geometryViewer.html.c66c780f.js"}